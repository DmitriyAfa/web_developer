export const questions1 = [
  {
    question: "Что такое TypeSript ",
    topics: {
      answer: [
        `Это язык программирования, который расширяет возможности JavaScript за счёт типизации``Выполняет свою работу до запуска кода (поэтому его называют статическим), значит разработчику не придётся запускать код что бы понять была ли допущена ошибка в типах`,
      ],
      id: 0,
    },
    id: 0,
  },
  {
    question: "Какие типы ошибок отлавивает TypeScript ",
    topics: [
      {
        answer: [
          `Позволяет перехватить многие "легальные" ошибки с точки зрения JavaScript спецификации: `,
          `попытка доступа к несуществующему объекту`,
          `опечатки`,
          `функции которые не были вызваны`,
          `логические ошибки`,
        ],
        id: 0,
      },
    ],
    id: 1,
  },
  {
    question: "Как работает TypeScript",
    topics: [
      {
        answer: [
          `TypeScript обладает информацией о типах которые мы используем в коде и на основе этой информации он наичнает предполагать свойство с каким типом мы хотим использовать`,
        ],
        id: 0,
      },
    ],
    id: 2,
  },
  {
    question: "Может ли TypeScript компилировать с ошибками",
    topics: [
      {
        answer: [
          `TypeScript может компилировать в JavaScript с ошибками допущенными в типизации. Потому что TypeScript считает вас умнее себя.`,
          `Чтобы этого избежать можно установить специальный флаг при компиляции "--noEmitOnError"`,
        ],
        id: 0,
      },
    ],
    id: 3,
  },
  {
    question: "Какие примитивы используются",
    topics: [
      {
        answer: [`Типы: string, number и boolean`],
        id: 0,
      },
    ],
    id: 4,
  },
  {
    question: "Основные типы в TypeScript",
    topics: [
      {
        topic: "Массивы",
        answer: [
          `Для определения типа массива [1,2,3] можно использовать синтаксис "number[]".`,
          `Такой синтаксис подходит для любого типа, например "string[]" - это массив строк`,
          `Так же можно встретить "Array[number]", тоже самое что и "number[]". Такой синтаксис обычно используется для определения общих типов или дженериков`,
          `Обратите внимание "[number]" - это дрйго тип, кортеж(tuple)`,
        ],
        id: 0,
      },
      {
        topic: "any",
        answer: [`Отключает проверку типов`],
        id: 1,
      },
      {
        topic: "Функции",
        answer: [
          `Можно определить тип входных параметров. Так же проверяется кол-во входных аргументов, вне зависимости указаны ли типы у параметров или нет`,
          `Аннотация типа возвращаемого значения`,
        ],
        id: 2,
      },
      {
        topic: "Анонимные функции",
        answer: [
          `Если анониманя функция появляется где TS может определить способ ее вызова, то типы ее параметров определяются автоматически`,
        ],
        id: 3,
      },
      {
        topic: "типы объекта",
        answer: [
          `Объект - это пара ключ-значение, где значением может быть любой тип. Поэтому для определения свойств объекта нужно перечислить их и их типы "function printCoords(pt: { x: number; y: number }) {...} ---> printCoords({ x: 3, y: 7 })" `,
          `Свойство без явно определенного типа будет иметь тип any`,
        ],
        id: 4,
      },
      {
        topic: "Опциональные свойства",
        answer: [
          `Для определения свойства как опционального ставим символ "?" после названия свойства "function myFunc (obj: {a: string, b?: number})". Теперь не обязательно передавать в функцию myFunc второй аргумент, но в таком случае значение второго аргумента будет undefined. Для чтения опционального аргумента в функции нужно сделать его проверку на undefined`,
        ],
        id: 5,
      },
      {
        topic: "Объединения (unions)",
        answer: [
          `Это тип сформированный из 2-х и более типов, является значением которое может иметь один из этих типов. "function myFunc(id: string|number){...}"`,
          `Когда речь идет об объединениях, то мы можем делать только то, что является примелимым для обоих типов. Так мы не может вызвать методы которые есть только у string.
          Но мы можем решить эту проблему благодаря условиям в которых будем как-то проверять тип union. Но если речь идёт о методах которые есть у общих типов, то все ок
          `,
        ],
        id: 6,
      },
      {
        topic: "Псевдонимы типов (type aliases)",
        answer: [
          `"type Point = {
            x: number
            y: number
          }"`,
          `Нужны когда нужно использовать одни и те же типы в разных местах. Сокращает написание когда и позволяет избежать ошибки при написании одного и того же`,
        ],
        id: 7,
      },
      {
        topic: "interfaces",
        answer: [
          `"interface Point {
          x: number
          y: number
        }"`,
          `Похож на type, но имеет синтаксис без знака =. `,
        ],
        id: 7,
      },
    ],
    id: 5,
  },
  {
    question: "Разница между type и interface",
    topics: [
      {
        answer: [
          `Разница type не может повторно быть открыт для добавления свойства (некая константа), в то время как в interface можно добавить новые свойства. Но можно обойти запрет на расширение type с помощью пересечения (intersection)`,
        ],
        id: 0,
      },
    ],
    id: 6,
  },
];
