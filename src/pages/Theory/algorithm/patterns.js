/**
 * Паттерны алгоритмов
 *
 * Метод скользящего окна - распространенная стратегия оптимизации алгоритма.
 *
 * Признаки для использования данного алгоритма:
 * Обычно есть неотсортированные массивы.
 * Задача заключается в поиске непрерывного подмассива, который соответствует
 * определенным кретериям.
 * Непрерывный означает что искомые элементы в подмассиве соприкасаются,
 * так мы не пропускаем ни одного числа в подмассиве чтобы получить ответ.
 *
 * Например:
 *  const array = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
 * В этом массиве ['a', 'b', 'c'] является непрерывным подмассивом,
 * а ['b','d','e'] не является таковым, потому что 'b' не касается 'd' в array
 *
 *
 * Далее можно классифицировать скользящие окна как проблемы со статическими окнами
 * и как проблемы с динамическими окнами.
 *
 * В задачах со статическими окнами нам всегда нужно будет искать подмассив/подстроку
 * определенной длины, например: "найти максимальную сумму "k" смежных целых чисел
 * в массиве целых чисел". Здесь у нас будет окно размера k, которое останется размером k
 * на протяжении всей задачи.
 *
 */
let k = 5;
let array = [1, 5, 3, 6, 8, 3, 6, 8, 0, 3, 6];
/**
 * Метод скользящего окна заключается в том, что отслеживается
 * предыдущая сумма k элементов
 *
 * Создадим переменную куда будем передавать максимальную сумму
 * let maxSum = 0;
 * Переменную куда будем передавать сумму текущего окна
 * let windowSum = 0;
 * И стартовую точку для итерации по массиву
 * let start = 0;
 * Пройдёмся циклом for по длинне массива, инициализируем счётчик который будет использоваться в последующем в условии в качестве правого ограничителя для длинны окна (k)
 * (let end = 0; end < arr.length; end++)
 * Складываем в сумму текущего окна значение текущего элемента массива
 * windowSum += arr[end]
 * Задаём условие если счётчик цикла больше или равно k - 1. k - 1 так как end начинается с нуля. то есть если счётчик цикла равен заданному окну
 * if(end >= k-1)
 * тогда присвоем максимальной сумме сумму которая больше при сравнении максимальной суммы и суммы текущего окна
 * maxSum = Math.max(maxSum, widowSum);
 * Сдвигаем окно на шаг вправо, для этого вычитаем из суммы текущего окна значение первого элемента окна слева
 * windowSum -= arr[start]
 * Для следующей итерации сдвинем стартовую точку вправо
 * start++
 * На выходе из функции вернём максимальную сумму
 * return maxSum;
 */

// function maxSubArrayOfsizeK(k, arr) {
//   let maxSum = 0;
//   let winodwSum = 0;
//   let start = 0;
//   for (let end = 0; end < arr.length; end++) {
//     winodwSum += arr[end];
//     if (end >= k - 1) {
//       maxSum = Math.max(maxSum, winodwSum);
//       winodwSum -= arr[start];
//       start++;
//     }
//   }
//   return maxSum;
// }

// console.log(maxSubArrayOfsizeK(k, array)); // ---> 31

/**
 * Динамические окна
 * Метод похож на два указателя, но вместо того, чтобы заботиться о каждом указателе,
 * мы заботимся обовсем между указателями.
 *
 * Пример, "найти длину наименьшего непрерывного подмассива с суммой, большей или равной заданному значению"
 *
 * В этом случае мы проверяем разную длину окна.
 * Нужно начав с первого элемента массива расширять окно, пока не достигнем суммы.
 * Затем сжимаем окно, перемещая начало окна вперед. Как только значение опускается ниже сумыы, нам придется снова расширить
 * окно, переместив конец окна вперед.
 *
 */

// let sum = 10;
// let arr2 = [1, 5, 3, 6, 8, 3];

// function findMinLengthOfSumK(k, arr) {
//   let minLength = Infinity;
//   let windowSum = 0;
//   let start = 0;
//   for (let end = 0; end < arr.length; end++) {
//     windowSum += arr[end];
//     if (windowSum >= k) {
//       while (windowSum >= k) {
//         minLength = Math.min(minLength, end - start);
//         windowSum -= arr[start];
//         start--;
//       }
//     }
//   }
//   return minLength;
// }

// console.log(findMinLengthOfSumK(sum, arr2));
